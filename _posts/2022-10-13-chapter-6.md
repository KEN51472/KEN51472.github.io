---
layout: detail
type : 2
keyword : C++ Network Programming Volume
title: C++ Network Programming Volume ：Chapter 5
description: Concurrency Design Dimensions
---

## CHAPTER 5
## Concurrency Design Dimensions


### 迭代式、并发式、反应式服务器

服务器可以分为迭代式、并发式或反应式。主要权衡涉及编程的简单性与扩展以增加服务产品和主机负载的能力。    

迭代服务器在为后续请求提供服务之前，会完整地处理每个客户端请求。因此，在处理请求时，迭代服务器要么排队要么忽略其他请求。  
迭代服务器适合
1. 短期服务，例如标准互联网 ECHO 和 DAYTIME 服务，具有最小的执行时间变化
2. 不经常运行的服务，例如每晚在平台轻负载时运行的远程文件系统备份服务  

并发服务器同时处理来自客户端的多个请求，根据操作系统和硬件平台，并发服务器可以使用多个线程或多个进程执行其服务。如果服务器是单服务服务器，同一服务的多个副本可以同时运行。如果服务器是多服务服务器，则不同服务的多个副本也可能同时运行。  

并发服务器非常适合 I/O 密集型服务和/或需要可变时间来执行的长时间服务。与迭代服务器不同，并发服务器允许更细粒度的同步技术，在应用程序定义的级别序列化请求。这种设计需要同步机制，以确保同时运行的进程和线程之间的稳健合作和数据共享。  

反应式服务器几乎同时处理多个请求，尽管所有处理实际上都是在单个线程中完成的。在 OS 平台上广泛使用多线程之前，并发处理通常通过同步事件多路分解策略实现，其中多个服务请求由单线程进程以循环顺序处理。  

反应式服务器可以通过同步事件多路分离机制显式地对每个请求进行时间切片来实现  

使用这种技术开发的应用程序具有以下限制： 

1. 增加编程复杂性。某些类型的网络应用程序，例如 I/O 绑定服务器，很难使用反应式服务器模型进行编程。

2. 降低可靠性和性能。如果单个操作失败，则整个服务器进程可能会挂起，即使整个进程没有失败，如果操作系统在一个服务调用系统函数或发生页面错误时阻塞整个进程，它的性能也会下降。

### 进程与线程

多进程将多个任务分配到不同的cpu上，从而实现同一时刻，处理多个任务  

多线程是实现并发的一个手段。一个进程可以拥有多个线程。当有多个cpu时，多个线程是可以同时执行的，这时就是并行。如果只有一个cpu，那么多个线程可以交叉重叠执行，这时就是并发了。

多进程和多线程比较起来，多线程一般适用于IO密集型的任务。多进程适用于计算密集型的任务。

多进程:进程是为执行程序指令提供上下文的操作系统实体。每个进程管理某些资源，例如虚拟内存、I/O 句柄和信号处理程序，并通过内存管理单元 (MMU)硬件免受其他操作系统进程的影响。由UNIX 上的fork()和 Win32 上的CreateProcess()创建进程。  

多线程:大多数操作系统平台现在都支持进程内的多个线程。线程是在进程保护域的上下文中执行的单个指令步骤序列。除了指令指针之外，线程还管理某些资源，例如函数激活记录的运行时堆栈、一组寄存器、信号掩码、优先级和线程特定的数据。如果有多个 CPU 可用，多线程服务器中的服务可以并行执行。在许多版本的 UNIX 上，线程是由pthread_create()产生的；在 Win32 上，它们由CreateThread()产生。

在单独的线程中(而不是在单独的进程中)执行多个操作的并发网络应用程序可以减少以下并发开销来源：

1. 线程创建和上下文切换。由于线程维护的状态少于进程，因此线程创建和上下文切换开销可能低于相应的进程生命周期活动。

2. 同步。在调度和执行应用程序线程时，可能不需要在内核模式和用户模式之间切换。同样，进程内同步通常比进程间同步更便宜，因为正在同步的对象是进程本地的，因此可能不需要内核干预。相比之下，进程间线程同步通常涉及操作系统内核。

3. 数据复制。线程可以使用进程本地内存共享信息，这有以下好处：

它通常比使用共享内存或本地 IPC 机制在进程之间进行通信更有效，因为不需要通过内核复制数据。

在进程本地内存中使用 C++ 对象更容易。


使用多线程实现并发应用程序时会出现以下限制：

1. 性能下降。一个常见的误解是线程固有地提高了应用程序的性能。然而，很多时候，线程并没有提高性能有几个原因，包括：

单处理器上的计算绑定应用程序不会从多线程中受益，因为计算和通信不能并行运行。

细粒度的锁定策略会产生高同步开销，这会阻止应用程序充分利用并行处理的好处。

2. 降低稳健性。为了减少上下文切换和同步开销，线程彼此之间接收很少或没有 MMU 保护。在单个进程地址空间中通过线程执行所有任务会降低应用程序的健壮性，原因有几个，包括：

同一进程地址空间中的单独线程彼此之间没有得到很好的保护。因此，进程中的一个故障服务可能会破坏进程中其他线程上运行的服务共享的全局数据。反过来，这可能会产生不正确的结果、使整个进程崩溃或导致应用程序无限期挂起。

在一个线程中调用的某些 OS 函数可能会对整个进程产生不良的副作用；例如，UNIX exit()和 Win32 ExitProcess()函数具有终止进程中所有线程的副作用。

3. 缺乏细粒度的访问控制。在大多数操作系统上，进程是访问控制的粒度。因此，多线程的另一个限制是进程中的所有线程共享相同的用户 ID 以及对文件和其他受保护资源的访问权限。为了防止意外或有意访问未经授权的资源，基于进程所有权的安全机制的网络服务（例如 TELNET）通常在单独的进程中运行。

### 进程/线程生成策略

饥饿式创建。在服务器创建时预生成一个或多个操作系统进程或线程。这些“热启动”执行资源形成一个池，通过在必须为请求提供服务之前产生服务启动开销来提高响应时间。但启动速度慢。适用于线程创建和销毁频繁的大规模并发应用中。

按需创建。启动速度快，单个响应速度慢。适用于线程创建和销毁不很频繁的应用。此模式定义了一个高效的并发模型，其中多个线程轮流共享一组事件源，以检测、解复用、分派和处理发生在事件源上的服务请求。当池线程对请求的处理没有同步或排序约束时，可以使用领导者/跟随者模式代替半同步/半异步模式来提高性能。


### 用户、内核和混合线程模型

N:1 用户线程模型  

库调度器从进程的多个线程中选择一个线程，然后该线程和该进程允许的一个内核线程关联起来。内核线程将被操作系统调度器指派到处理器内核。用户级线程是一种”多对一”的线程映射  
内核对线程包一无所知。从内核角度考虑，就是按正常的方式管理，即单线程进程（存在运行时系统）

1:1 内核线程模型  

内核线程驻留在内核空间，它们是内核对象。有了内核线程，每个用户线程被映射或绑定到一个内核线程。用户线程在其生命期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作”一对一”线程映射  

操作系统调度器管理、调度并分派这些线程。运行时库为每个用户级线程请求一个内核级线程。操作系统的内存管理和调度子系统必须要考虑到数量巨大的用户级线程。您必须了解每个进程允许的线程的最大数目是多少。操作系统为每个线程创建上下文。进程的每个线程在资源可用时都可以被指派到处理器内核  

N:M 混合线程模型。提供 N:1 和 1:1 模型的组合，称为“N:M”混合线程模型。该模型支持混合使用用户线程和内核线程


### 分时、实时调度类

分时调度类：基于优先级；公平；抢占式；时间分片

实时调度类：限制了调度用户所需的最坏情况时间线程或内核线程。循环；先进先出

当操作系统同时支持分时和实时调度类时，实时线程总是以比任何分时线程更高的优先级运行。

### 基于任务、基于消息的架构

基于任务的并发架构：任务是主动的，任务处理的消息是被动的。并发是通过在不同的 CPU 中执行服务任务并在任务/​​CPU 之间传递数据消息和控制消息来实现的。基于任务的并发架构可以使用生产者/消费者模式来实现

基于消息的并发架构：消息是主动的，任务是被动的。并发是通过同时通过一组服务任务在不同的 CPU 上引导多条消息来实现的。