---
layout: detail
type : 4
keyword : UNIX环境高级编程
title: UNIX环境高级编程 ：Chapter 1
description: 
---

## CHAPTER 1

## 库函数 系统调用

区别：

执行方式：系统调用是通过用户程序向操作系统发起请求，操作系统在内核态下执行相应的操作。库函数是由用户程序直接调用，函数的执行是在用户程序的上下文中进行的。
访问权限：系统调用只能通过操作系统提供的接口进行访问，用户程序不能直接访问操作系统的内核态。库函数则可以由用户程序直接调用，不需要特殊的权限。
功能范围：系统调用提供了广泛的操作系统功能，包括进程管理、文件系统、网络通信等。库函数则提供了特定领域的功能，例如字符串处理、数学运算、图形界面等。
性能开销：由于系统调用涉及用户态和内核态之间的切换，因此执行系统调用会有一定的性能开销。而库函数的执行则是在用户态下进行，开销相对较小。

在编程中，一般建议尽可能使用库函数来完成任务，因为库函数提供了更高级别的抽象和易用性。只有在需要直接访问底层系统资源或执行特定的操作时，才需要使用系统调用。库函数可以简化编程过程，提高开发效率，同时也能够提供跨平台的兼容性。

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    // 使用库函数输出文本
    printf("Hello, World!\n");

    // 使用系统调用输出文本
    write(1, "Hello, World!\n", 14);

    return 0;
}

```

在上述代码中使用了两种方式输出相同的文本

第一种方式是使用库函数 printf()，是C语言提供的一个库函数，是一个高级别的抽象，隐藏了底层的系统调用细节。

第二种方式是使用系统调用 write()。write() 是一个系统调用，是一个低级别的操作，需要直接调用系统调用接口。

这两种方式实现了相同的功能，但它们的执行方式和访问权限有所不同。使用库函数 printf() 可以直接在用户程序中调用，而系统调用 write() 则需要使用特定的系统调用接口。此外，由于涉及用户态和内核态之间的切换，使用系统调用会有一定的性能开销，而库函数的执行则是在用户态下进行，开销相对较小。

在实际编程中，我们通常会使用库函数来完成常见的任务，因为它们提供了更高级别的抽象和易用性。只有在需要直接访问底层系统资源或执行特定的操作时，才需要使用系统调用。
在Linux的系统调用文档中，系统调用函数会被标记为 "SYSCALL" 或 "SYSTEM CALL"，并提供了相应的函数原型和参数说明。

## 信号处理 

```c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

// 定义信号处理函数
void signal_handler(int signal) {
    printf("Received signal: %d\n", signal);
    // 在这里可以添加自定义的信号处理逻辑
}

int main() {
    // 注册信号处理函数
    signal(SIGINT, signal_handler); // 捕捉Ctrl+C信号
    printf("Waiting for signal...\n");

    // 进入无限循环，等待信号
    while(1) {
        // 在这里可以执行其他任务
    }

    return 0;
}

```

1. #include <signal.h>：包含信号处理相关的头文件。

2. void signal_handler(int signal)：定义一个信号处理函数，该函数会在捕捉到信号时被调用。在这个示例中，我们简单地打印出接收到的信号编号。

3. signal(SIGINT, signal_handler)：使用signal函数注册信号处理函数。SIGINT是一个常量，表示终端中断信号（通常是由Ctrl+C发送）。当捕捉到该信号时，将执行signal_handler函数。

通过以上代码，当运行程序并按下Ctrl+C时，会触发SIGINT信号，然后信号处理函数signal_handler会被调用，打印出接收到的信号编号。你根据实际需求，在信号处理函数中添加自定义的信号处理逻辑。


在Linux和Unix系统中，Ctrl+C信号（SIGINT）是由操作系统发送给正在运行的程序的。当用户在终端按下Ctrl+C时，终端会将这个信号发送给前台运行的程序。程序可以通过注册信号处理函数来捕捉和处理这个信号。d

Ctrl+C信号是终端发送的中断信号，用于请求程序终止。除了Ctrl+C，还有其他一些信号可以用于与程序进行交互，如Ctrl+Z（SIGTSTP）用于暂停程序，Ctrl+\（SIGQUIT）用于强制终止程序等。通过注册相应的信号处理函数来捕捉和处理这些信号。


## open 与 fopen

open和fopen都用于打开文件在使用方式和功能上主要有以下区别：

open函数：

open函数是系统调用函数，用于打开文件并返回一个文件描述符  
int open(const char *pathname, int flags, mode_t mode);  
pathname表示要打开的文件路径名，flags表示打开文件的方式和选项，mode表示新建文件的权限。  
返回一个非负整数的文件描述符，表示打开的文件，失败则返回-1，并设置相应的错误码。  


fopen函数：

fopen函数是标准C库提供的函数，用于打开文件并返回一个文件指针  
FILE *fopen(const char *pathname, const char *mode);  
pathname表示要打开的文件路径名，mode表示打开文件的方式和选项。  
fopen函数返回一个指向FILE结构的指针，表示打开的文件，失败则返回NULL。  


区别：

open是系统调用函数，而fopen是标准C库函数。在性能方面，open函数通常比fopen函数更高效。这是因为open函数是一个系统调用，直接与操作系统内核交互，而fopen函数是一个标准C库函数，需要经过一层函数调用和额外的缓冲区管理。  
open函数返回一个文件描述符，而fopen函数返回一个文件指针。  
open函数提供了更底层的文件操作能力，可以对文件进行更细粒度的控制，如读写权限、文件标志等。而fopen函数则提供了更高层次的文件操作接口，封装了许多常用的文件读写操作。  
open函数的错误处理更直接，通过返回值和设置错误码来表示失败的原因。而fopen函数可以通过检查返回的指针是否为NULL来判断是否成功打开文件，并通过errno全局变量来获取具体的错误信息。  
如果需要更底层的文件操作能力，可以使用open函数；如果需要更高层次的文件读写接口，可以使用fopen函数。  

调用开销：open函数是一个系统调用，涉及到用户态和内核态之间的切换，这可能会引入一定的开销。而fopen函数是一个库函数，直接在用户态执行，调用开销较小。  

缓冲区管理：fopen函数会在内存中维护一个缓冲区，用于提高文件读写的效率。这意味着在使用fopen函数进行文件读写时，数据首先被写入缓冲区，然后在适当的时机才会被写入磁盘。这种缓冲区管理可以减少磁盘I/O操作的次数，提高性能。但是，如果需要立即将数据写入磁盘，可能需要额外的操作，如fflush函数。  

文件描述符管理：open函数返回的是文件描述符，它是一个整数值。在进行文件操作时，可以直接使用文件描述符进行读写操作，而无需通过文件指针。这可以减少一些额外的指针操作和函数调用，提高性能。  
