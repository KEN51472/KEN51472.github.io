---
layout: detail
type : 2
keyword :     
title: lvalue rvalue & move
description: 左值 右值 和 std::move
---

## lvalue 和 rvalue

lvalue 左值：通常指向内存中的某个对象或变量的表达式，可以取地址。简单来说，lvalue就是可以放在赋值号左边的表达式，比如变量、数组元素、引用等。
rvalue 右值：通常是“临时”的值，不可以取地址。比如常量、临时变量、表达式的计算结果等。在C++11之后，rvalue还包括了移动语义中的右值引用。

## std::move

std::move是一个定义在头文件<utility>中的函数模板，它的作用是将一个对象转换为对应的右值引用。std::move并不会真正移动数据，而是通过将左值转换为右值引用的方式，告诉编译器我们希望以移动的方式来处理数据，从而触发移动语义的操作。这样可以在适当的时候使用移动语义而不是拷贝语义，提高性能。
在使用std::move时，我们通常会将其用于移动语义的场景，比如在实现移动构造函数、移动赋值运算符或者在使用支持移动语义的标准库类型时。


## 拷贝构造 和 移动构造

在C++11之前，如果我们想要使用移动语义，通常会使用拷贝构造函数来实现，比如MyClass的拷贝构造函数：

```c
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass& other) {
        // 执行拷贝操作，将other的资源复制给当前对象
    }
    // 其他成员和方法
};

```
在这种情况下，如果我们想要将obj1的资源转移到obj2，我们会写成这样：

```c
MyClass obj1;
MyClass obj2 = obj1;  // 调用拷贝构造函数，执行复制操作

```

但是，如果MyClass有移动构造函数，我们希望使用移动语义来实现资源的转移，这时就可以使用std::move：

```c
MyClass obj1;
MyClass obj2 = std::move(obj1);  // 调用移动构造函数，执行移动操作
```

这样，通过使用std::move，我们可以告诉编译器我们希望使用移动构造函数来处理obj1，而不是拷贝构造函数，实现了资源的转移。

因此，可以认为std::move的作用是改变表达式的类型，让编译器知道我们想要使用移动语义来处理数据，从而实现资源的转移。std::move的作用就是为了在适当的时候使用移动语义而不是拷贝语义。