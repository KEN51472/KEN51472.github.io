---
layout: detail
type : 2
keyword :     
title: memory map
description: 
---

## 内存映射

内存映射（Memory Mapping）是一种将文件的内容直接映射到进程的地址空间中的技术。这样做可以使得文件的内容可以像内存一样被访问，从而可以通过内存操作来读取和写入文件，而无需进行显式的文件I/O操作。在C++中，可以使用操作系统提供的相关API来进行内存映射，比如在Linux下可以使用mmap函数

好处主要有以下几点：

提高文件读写效率
内存映射技术可以将文件的内容直接映射到进程的地址空间中，从而可以像访问内存一样访问文件的内容。避免频繁的文件I/O操作，提高文件读写效率。

方便文件的随机访问
内存映射技术可以将文件的任意部分映射到内存中，可以方便地进行文件的随机访问。通过指针可以直接访问文件的任意位置，无需像传统的文件I/O操作那样需要先定位文件指针。

简化代码实现
内存映射技术可以将文件的内容直接映射到内存中，通过内存操作来读写文件，简化代码的实现。不需要使用繁琐的文件I/O操作，可以直接使用内存操作来读写文件。

共享内存
内存映射技术可以将文件映射到多个进程的地址空间中，实现共享内存。这样可以方便地进行进程间通信，比如实现进程间共享数据等。

## 虚拟地址映射物理地址

虚拟地址：
虚拟地址空间是由操作系统提供的资源，是每个进程独立的地址空间，用于存放进程的代码、数据和堆栈等信息。虚拟地址空间并不直接对应于物理内存或磁盘空间，而是通过操作系统的内存管理单元（MMU）和页表来映射到实际的物理内存或磁盘中的数据。

在现代操作系统中，每个进程都有自己的虚拟地址空间，每个进程能够独立地访问自己的内存空间，而不受其他进程的影响。这种隔离和保护可以防止一个进程意外地修改另一个进程的数据，提高了系统的稳定性和安全性。

虚拟地址空间的映射是为了实现内存的分页和虚拟内存管理。通过虚拟地址空间的映射，操作系统可以将进程的虚拟地址空间映射到物理内存中的实际地址，或者在需要时将数据从磁盘加载到内存中。这样可以实现更高效的内存利用，允许进程访问比物理内存更大的地址空间，以及实现内存的共享和保护机制。


64位CPU地址空间可分为三个部分：
128T用户空间   
128T内核空间   
其他：保留空间


用户空间和内核空间共256T，2的48次方刚好为256T，所以48位地址空间能映射所有的虚拟地址。   
48位虚拟地址由五部分组成：   
pgd表偏移，四级表，9位   
pud表偏移，三级表，9位   
pmd表偏移，二级表，9位   
ptl表偏移，一级表，9位   
物理页偏移，12位   

一张pgd表对应一个物理页，一个物理页的大小为4KB，一个pgd_t表项为8个字节，一张pgd表能存储4*1024/8=512个表项。
2的9次方等于512，所以采用9位的表偏移就能索引整张表的表项。

一个物理页为4KB，物理页访问是单字节访问，2的12次方刚好为4KB，所以物理页偏移为12位。

## 虚拟地址映射物理地址过程
虚拟地址映射物理地址需要依次索引pgd，pud，pmd，ptl表

首先需要找到pgd表物理页首地址，pgd表物理页首地址由task_struct->mm_struct->pgd成员保存，每个进程的task_struct->mm_struct->pgd成员数值不同，所以不同的进程即使使用相同的虚拟地址也不会访问相同到物理地址。
通过pgd表首地址+虚拟地址pgd表偏移索引到pgd_t表项完成pgd表查询。


以此类推，最后定位到物理地址后，虚拟地址映射物理地址的过程就已完成
通常情况下，进程只会使用很小的内存，所以系统不会一下把所有的页表都创建出来，而是采用动态分配的方式创建，当需要访问虚拟地址时，通过缺页中断创建虚拟地址对应的各个页表

## mmap实现原理

mmap函数是一种内存映射文件的方法，它可以将一个文件或设备映射到进程的地址空间中，使得进程可以像访问内存一样访问文件或设备。
mmap可以分为：文件映射和匿名映射。
mmap函数主要工作就是创建VMA

VMA（Virtual Memory Area，虚拟内存区域）是Linux内核中用于管理进程虚拟内存的数据结构。每个进程都有一个VMA链表，用于描述进程的虚拟地址空间的不同区域。
VMA包含了一段连续的虚拟地址空间，它定义了该区域的起始地址、结束地址以及一些属性信息。VMA可以表示进程的代码段、数据段、堆、栈等不同的内存区域。
VMA对应Linux内核struct vm_area_struct对象。

VMA用于指导虚拟内存映射物理内存，没有VMA指导无法完成虚拟地址和物理地址映射

## 文件映射

文件映射可以将文件的内容映射到进程的内存空间。
文件映射pte指向文件的物理内存页，文件映射需要VMA指向对应的文件，由文件来生成物理页

mmap函数实现文件映射时需指定文件fd，文件偏移量，文件映射长度。
内核会根据文件fd，文件偏移量，文件映射长度填充新创建的VMA。
文件映射创建pte时根据VMA记录的文件file，文件偏移量，文件映射长度定位到具体文件以及文件偏移位置，将磁盘文件内容拷贝至物理内存页，再将物理内存页转换成pte设置进ptl表。
至此文件映射已完成，就能通过虚拟地址访问文件物理内存页

## 匿名映射

匿名映射是指在进程的地址空间中创建一块不与任何文件关联的内存映射。这种映射不会对应任何磁盘上的文件，而是直接映射到内存中的页面。

使用场景：
使用：

当进程需要共享内存给其他进程时，可以使用匿名映射来实现共享内存的功能，从而实现进程间通信。
当需要动态分配一块内存，而不希望将数据写入到磁盘文件时，可以使用匿名映射来分配内存。
当需要实现内存中的临时缓存时，可以使用匿名映射来创建缓存区域。

匿名映射相对来说比较简单，只要在创建pte的时候，从物理内存中申请一个物理内存页，将物理内存页转换成pte设置进ptl表，就完成匿名映射

## 代码实现

```c
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("file.txt", O_RDWR); // 打开文件
    struct stat sb;
    fstat(fd, &sb); // 获取文件信息

    char *addr = (char *)mmap(NULL, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // 将文件映射到内存
    close(fd); // 关闭文件

    // 现在文件的内容已经映射到了内存中的addr指针所指向的位置
    // 可以通过addr指针来访问文件的内容
    std::cout << "File content: " << addr << std::endl;

    // 修改文件内容
    addr[0] = 'H';
    addr[1] = 'i';

    // 取消内存映射
    munmap(addr, sb.st_size);
    
    return 0;
}
```

使用 memory map 的时候需要小心处理数据的一致性和同步问题

## mmap 方法参数
```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

addr：指定映射区域的开始地址，通常设为0，表示由系统自动选择地址
length：指定映射区域的长度，以字节为单位
prot：指定映射区域的保护方式，可选：
PROT_READ：映射区域可读
PROT_WRITE：映射区域可写
PROT_EXEC：映射区域可执行
PROT_NONE：映射区域不可访问
flags：指定映射区域的属性，可选：
MAP_SHARED：映射区域会与文件关联，对映射区域的写入会直接反映到文件中
MAP_PRIVATE：创建一个新的私有映射区域，对映射区域的写入不会反映到文件中
MAP_ANONYMOUS：映射一个匿名映射区域，不与文件关联
fd：指定要映射的文件描述符，如果是匿名映射，则为-1
offset：指定文件映射的偏移量，通常设为0