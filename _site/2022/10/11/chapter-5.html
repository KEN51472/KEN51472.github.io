<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="http://localhost:4000/assets/css/main.css" />
    <noscript>
        <link rel="stylesheet" href="http://localhost:4000/assets/css/noscript.css" />
    </noscript>
</head>

<body class="is-preload">

    <!-- Wrapper -->
    <div id="wrapper">
        <!-- Header -->
<header id="header" class="alt">
	<a href="index.html" class="logo"><strong>KEN</strong> <span>BLOG</span></a>
	<nav>
		<a href="#menu">Menu</a>
	</nav>
</header>
        <!-- Menu -->
<nav id="menu">
    <ul class="links">
        <li><a href="index.html">Home</a></li>
        <li><a href="http://localhost:4000/_layouts/landing.html">Landing</a></li>
        <li><a href="http://localhost:4000/_layouts/generic.html">Generic</a></li>
        <li><a href="http://localhost:4000/_layouts/elements.html">Elements</a></li>
    </ul>
</nav>
        <!-- Main -->
<div id="main" class="alt">

	<!-- One -->
	<section id="one">
		<div class="inner">
			<p3><h2 id="chapter-5">CHAPTER 5</h2>
<h2 id="concurrency-design-dimensions">Concurrency Design Dimensions</h2>

<h3 id="iterative-concurrent-and-reactive-servers">Iterative, Concurrent, and Reactive Servers</h3>

<p>服务器可以分为迭代式、并发式或反应式。主要权衡涉及编程的简单性与扩展以增加服务产品和主机负载的能力。</p>

<p>迭代服务器在为后续请求提供服务之前，会完整地处理每个客户端请求。因此，在处理请求时，迭代服务器要么排队要么忽略其他请求。<br />
迭代服务器适合</p>
<ol>
  <li>短期服务，例如标准互联网 ECHO 和 DAYTIME 服务，具有最小的执行时间变化</li>
  <li>不经常运行的服务，例如每晚在平台轻负载时运行的远程文件系统备份服务</li>
</ol>

<p>并发服务器同时处理来自客户端的多个请求，根据操作系统和硬件平台，并发服务器可以使用多个线程或多个进程执行其服务。如果服务器是单服务服务器，同一服务的多个副本可以同时运行。如果服务器是多服务服务器，则不同服务的多个副本也可能同时运行。</p>

<p>并发服务器非常适合 I/O 密集型服务和/或需要可变时间来执行的长时间服务。与迭代服务器不同，并发服务器允许更细粒度的同步技术，在应用程序定义的级别序列化请求。这种设计需要同步机制，以确保同时运行的进程和线程之间的稳健合作和数据共享。</p>

<p>反应式服务器几乎同时处理多个请求，尽管所有处理实际上都是在单个线程中完成的。在 OS 平台上广泛使用多线程之前，并发处理通常通过同步事件多路分解策略实现，其中多个服务请求由单线程进程以循环顺序处理。</p>

<p>反应式服务器可以通过同步事件多路分离机制显式地对每个请求进行时间切片来实现</p>

<p>使用这种技术开发的应用程序具有以下限制：</p>

<ol>
  <li>
    <p>增加编程复杂性。某些类型的网络应用程序，例如 I/O 绑定服务器，很难使用反应式服务器模型进行编程。</p>
  </li>
  <li>
    <p>降低可靠性和性能。如果单个操作失败，则整个服务器进程可能会挂起，即使整个进程没有失败，如果操作系统在一个服务调用系统函数或发生页面错误时阻塞整个进程，它的性能也会下降。</p>
  </li>
</ol>

<h3 id="processes-versus-threads">Processes versus Threads</h3>

<p>多进程将多个任务分配到不同的cpu上，从而实现同一时刻，处理多个任务</p>

<p>多线程是实现并发的一个手段。一个进程可以拥有多个线程。当有多个cpu时，多个线程是可以同时执行的，这时就是并行。如果只有一个cpu，那么多个线程可以交叉重叠执行，这时就是并发了。</p>

<p>多进程和多线程比较起来，多线程一般适用于IO密集型的任务。多进程适用于计算密集型的任务。</p>

<p>多进程:进程是为执行程序指令提供上下文的操作系统实体。每个进程管理某些资源，例如虚拟内存、I/O 句柄和信号处理程序，并通过内存管理单元 (MMU)硬件免受其他操作系统进程的影响。由UNIX 上的fork()和 Win32 上的CreateProcess()创建进程。</p>

<p>多线程:大多数操作系统平台现在都支持进程内的多个线程。线程是在进程保护域的上下文中执行的单个指令步骤序列。除了指令指针之外，线程还管理某些资源，例如函数激活记录的运行时堆栈、一组寄存器、信号掩码、优先级和线程特定的数据。如果有多个 CPU 可用，多线程服务器中的服务可以并行执行。在许多版本的 UNIX 上，线程是由pthread_create()产生的；在 Win32 上，它们由CreateThread()产生。</p>

<p>在单独的线程中(而不是在单独的进程中)执行多个操作的并发网络应用程序可以减少以下并发开销来源：</p>

<ol>
  <li>
    <p>线程创建和上下文切换。由于线程维护的状态少于进程，因此线程创建和上下文切换开销可能低于相应的进程生命周期活动。</p>
  </li>
  <li>
    <p>同步。在调度和执行应用程序线程时，可能不需要在内核模式和用户模式之间切换。同样，进程内同步通常比进程间同步更便宜，因为正在同步的对象是进程本地的，因此可能不需要内核干预。相比之下，进程间线程同步通常涉及操作系统内核。</p>
  </li>
  <li>
    <p>数据复制。线程可以使用进程本地内存共享信息，这有以下好处：</p>
  </li>
</ol>

<p>它通常比使用共享内存或本地 IPC 机制在进程之间进行通信更有效，因为不需要通过内核复制数据。</p>

<p>在进程本地内存中使用 C++ 对象更容易。</p>

<p>使用多线程实现并发应用程序时会出现以下限制：</p>

<ol>
  <li>性能下降。一个常见的误解是线程固有地提高了应用程序的性能。然而，很多时候，线程并没有提高性能有几个原因，包括：</li>
</ol>

<p>单处理器上的计算绑定应用程序不会从多线程中受益，因为计算和通信不能并行运行。</p>

<p>细粒度的锁定策略会产生高同步开销，这会阻止应用程序充分利用并行处理的好处。</p>

<ol>
  <li>降低稳健性。为了减少上下文切换和同步开销，线程彼此之间接收很少或没有 MMU 保护。在单个进程地址空间中通过线程执行所有任务会降低应用程序的健壮性，原因有几个，包括：</li>
</ol>

<p>同一进程地址空间中的单独线程彼此之间没有得到很好的保护。因此，进程中的一个故障服务可能会破坏进程中其他线程上运行的服务共享的全局数据。反过来，这可能会产生不正确的结果、使整个进程崩溃或导致应用程序无限期挂起。</p>

<p>在一个线程中调用的某些 OS 函数可能会对整个进程产生不良的副作用；例如，UNIX exit()和 Win32 ExitProcess()函数具有终止进程中所有线程的副作用。</p>

<ol>
  <li>缺乏细粒度的访问控制。在大多数操作系统上，进程是访问控制的粒度。因此，多线程的另一个限制是进程中的所有线程共享相同的用户 ID 以及对文件和其他受保护资源的访问权限。为了防止意外或有意访问未经授权的资源，基于进程所有权的安全机制的网络服务（例如 TELNET）通常在单独的进程中运行。</li>
</ol>

<h3 id="processthread-spawning-strategies">Process/Thread Spawning Strategies</h3>

<p>按需派生策略。在服务器创建时预生成一个或多个操作系统进程或线程。这些“热启动”执行资源形成一个池，通过在必须为请求提供服务之前产生服务启动开销来提高响应时间。该池可以根据各种因素（例如可用 CPU 的数量、当前机器负载或客户端请求队列的长度）静态和/或动态地扩展或收缩。此设计使用半同步/半异步模式，它将来自 I/O 层的请求提供给线程池中的工作程序</p>

<p>领导者/跟随者模式管理线程池。此模式定义了一个高效的并发模型，其中多个线程轮流共享一组事件源，以检测、解复用、分派和处理发生在事件源上的服务请求。当池线程对请求的处理没有同步或排序约束时，可以使用领导者/跟随者模式代替半同步/半异步模式来提高性能。</p>

</p3>
		</div>
	</section>
</div>
        <!-- Footer -->
<footer id="footer">
	<div class="inner">
		<ul class="icons">
			<li><a href="#" class="icon brands alt fa-twitter"><span class="label">Twitter</span></a></li>
			<li><a href="#" class="icon brands alt fa-facebook-f"><span class="label">Facebook</span></a></li>
			<li><a href="#" class="icon brands alt fa-instagram"><span class="label">Instagram</span></a></li>
			<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
			<li><a href="#" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
		</ul>
	</div>
</footer>
        <!-- Scripts -->
        <script src="http://localhost:4000/assets/js/jquery.min.js"></script>
        <script src="http://localhost:4000/assets/js/jquery.scrolly.min.js"></script>
        <script src="http://localhost:4000/assets/js/jquery.scrollex.min.js"></script>
        <script src="http://localhost:4000/assets/js/browser.min.js"></script>
        <script src="http://localhost:4000/assets/js/breakpoints.min.js"></script>
        <script src="http://localhost:4000/assets/js/util.js"></script>
        <script src="http://localhost:4000/assets/js/main.js"></script>
    </div>
</body>

</html>