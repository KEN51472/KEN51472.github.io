<!DOCTYPE HTML>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/assets/css/main.css" />
    <noscript>
        <link rel="stylesheet" href="/assets/css/noscript.css" />
    </noscript>
</head>

<body class="is-preload">

    <!-- Wrapper -->
    <div id="wrapper">
        <!-- Header -->
<header id="header" class="alt">
	<a href="index.html" class="logo"><strong>KEN</strong> <span>BLOG</span></a>
	<nav>
		<a href="#menu">Menu</a>
	</nav>
</header>
        <!-- Menu -->
<nav id="menu">
    <ul class="links">
        <li><a href="index.html">Home</a></li>
        <li><a href="/_layouts/landing.html">Landing</a></li>
        <li><a href="/_layouts/generic.html">Generic</a></li>
        <li><a href="/_layouts/elements.html">Elements</a></li>
    </ul>
</nav>
        <!-- Main -->
<div id="main" class="alt">

	<!-- One -->
	<section id="one">
		<div class="inner">
			<p3><h2 id="chapter-1">CHAPTER 1</h2>

<h2 id="库函数-系统调用">库函数 系统调用</h2>

<p>区别：</p>

<p>执行方式：系统调用是通过用户程序向操作系统发起请求，操作系统在内核态下执行相应的操作。库函数是由用户程序直接调用，函数的执行是在用户程序的上下文中进行的。
访问权限：系统调用只能通过操作系统提供的接口进行访问，用户程序不能直接访问操作系统的内核态。库函数则可以由用户程序直接调用，不需要特殊的权限。
功能范围：系统调用提供了广泛的操作系统功能，包括进程管理、文件系统、网络通信等。库函数则提供了特定领域的功能，例如字符串处理、数学运算、图形界面等。
性能开销：由于系统调用涉及用户态和内核态之间的切换，因此执行系统调用会有一定的性能开销。而库函数的执行则是在用户态下进行，开销相对较小。</p>

<p>在编程中，一般建议尽可能使用库函数来完成任务，因为库函数提供了更高级别的抽象和易用性。只有在需要直接访问底层系统资源或执行特定的操作时，才需要使用系统调用。库函数可以简化编程过程，提高开发效率，同时也能够提供跨平台的兼容性。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用库函数输出文本</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, World!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// 使用系统调用输出文本</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Hello, World!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>在上述代码中使用了两种方式输出相同的文本</p>

<p>第一种方式是使用库函数 printf()，是C语言提供的一个库函数，是一个高级别的抽象，隐藏了底层的系统调用细节。</p>

<p>第二种方式是使用系统调用 write()。write() 是一个系统调用，是一个低级别的操作，需要直接调用系统调用接口。</p>

<p>这两种方式实现了相同的功能，但它们的执行方式和访问权限有所不同。使用库函数 printf() 可以直接在用户程序中调用，而系统调用 write() 则需要使用特定的系统调用接口。此外，由于涉及用户态和内核态之间的切换，使用系统调用会有一定的性能开销，而库函数的执行则是在用户态下进行，开销相对较小。</p>

<p>在实际编程中，我们通常会使用库函数来完成常见的任务，因为它们提供了更高级别的抽象和易用性。只有在需要直接访问底层系统资源或执行特定的操作时，才需要使用系统调用。
在Linux的系统调用文档中，系统调用函数会被标记为 “SYSCALL” 或 “SYSTEM CALL”，并提供了相应的函数原型和参数说明。</p>

<h2 id="信号处理">信号处理</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
</span>
<span class="c1">// 定义信号处理函数</span>
<span class="kt">void</span> <span class="nf">signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Received signal: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
    <span class="c1">// 在这里可以添加自定义的信号处理逻辑</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 注册信号处理函数</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signal_handler</span><span class="p">);</span> <span class="c1">// 捕捉Ctrl+C信号</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting for signal...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// 进入无限循环，等待信号</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 在这里可以执行其他任务</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<ol>
  <li>
    <p>#include <signal.h>：包含信号处理相关的头文件。</signal.h></p>
  </li>
  <li>
    <p>void signal_handler(int signal)：定义一个信号处理函数，该函数会在捕捉到信号时被调用。在这个示例中，我们简单地打印出接收到的信号编号。</p>
  </li>
  <li>
    <p>signal(SIGINT, signal_handler)：使用signal函数注册信号处理函数。SIGINT是一个常量，表示终端中断信号（通常是由Ctrl+C发送）。当捕捉到该信号时，将执行signal_handler函数。</p>
  </li>
</ol>

<p>通过以上代码，当运行程序并按下Ctrl+C时，会触发SIGINT信号，然后信号处理函数signal_handler会被调用，打印出接收到的信号编号。你根据实际需求，在信号处理函数中添加自定义的信号处理逻辑。</p>

<p>在Linux和Unix系统中，Ctrl+C信号（SIGINT）是由操作系统发送给正在运行的程序的。当用户在终端按下Ctrl+C时，终端会将这个信号发送给前台运行的程序。程序可以通过注册信号处理函数来捕捉和处理这个信号。d</p>

<p>Ctrl+C信号是终端发送的中断信号，用于请求程序终止。除了Ctrl+C，还有其他一些信号可以用于与程序进行交互，如Ctrl+Z（SIGTSTP）用于暂停程序，Ctrl+\（SIGQUIT）用于强制终止程序等。通过注册相应的信号处理函数来捕捉和处理这些信号。</p>

<h2 id="open-与-fopen">open 与 fopen</h2>

<p>open和fopen都用于打开文件在使用方式和功能上主要有以下区别：</p>

<p>open函数：</p>

<p>open函数是系统调用函数，用于打开文件并返回一个文件描述符<br />
int open(const char *pathname, int flags, mode_t mode);<br />
pathname表示要打开的文件路径名，flags表示打开文件的方式和选项，mode表示新建文件的权限。<br />
返回一个非负整数的文件描述符，表示打开的文件，失败则返回-1，并设置相应的错误码。</p>

<p>fopen函数：</p>

<p>fopen函数是标准C库提供的函数，用于打开文件并返回一个文件指针<br />
FILE *fopen(const char *pathname, const char *mode);<br />
pathname表示要打开的文件路径名，mode表示打开文件的方式和选项。<br />
fopen函数返回一个指向FILE结构的指针，表示打开的文件，失败则返回NULL。</p>

<p>区别：</p>

<p>open是系统调用函数，而fopen是标准C库函数。在性能方面，open函数通常比fopen函数更高效。这是因为open函数是一个系统调用，直接与操作系统内核交互，而fopen函数是一个标准C库函数，需要经过一层函数调用和额外的缓冲区管理。<br />
open函数返回一个文件描述符，而fopen函数返回一个文件指针。<br />
open函数提供了更底层的文件操作能力，可以对文件进行更细粒度的控制，如读写权限、文件标志等。而fopen函数则提供了更高层次的文件操作接口，封装了许多常用的文件读写操作。<br />
open函数的错误处理更直接，通过返回值和设置错误码来表示失败的原因。而fopen函数可以通过检查返回的指针是否为NULL来判断是否成功打开文件，并通过errno全局变量来获取具体的错误信息。<br />
如果需要更底层的文件操作能力，可以使用open函数；如果需要更高层次的文件读写接口，可以使用fopen函数。</p>

<p>调用开销：open函数是一个系统调用，涉及到用户态和内核态之间的切换，这可能会引入一定的开销。而fopen函数是一个库函数，直接在用户态执行，调用开销较小。</p>

<p>缓冲区管理：fopen函数会在内存中维护一个缓冲区，用于提高文件读写的效率。这意味着在使用fopen函数进行文件读写时，数据首先被写入缓冲区，然后在适当的时机才会被写入磁盘。这种缓冲区管理可以减少磁盘I/O操作的次数，提高性能。但是，如果需要立即将数据写入磁盘，可能需要额外的操作，如fflush函数。</p>

<p>文件描述符管理：open函数返回的是文件描述符，它是一个整数值。在进行文件操作时，可以直接使用文件描述符进行读写操作，而无需通过文件指针。这可以减少一些额外的指针操作和函数调用，提高性能。</p>
</p3>
		</div>
	</section>
</div>
        <!-- Footer -->
<footer id="footer">
	<div class="inner">
		<ul class="icons">
			<li><a href="#" class="icon brands alt fa-twitter"><span class="label">Twitter</span></a></li>
			<li><a href="#" class="icon brands alt fa-facebook-f"><span class="label">Facebook</span></a></li>
			<li><a href="#" class="icon brands alt fa-instagram"><span class="label">Instagram</span></a></li>
			<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
			<li><a href="#" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
		</ul>
	</div>
</footer>
        <!-- Scripts -->
        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/jquery.scrolly.min.js"></script>
        <script src="/assets/js/jquery.scrollex.min.js"></script>
        <script src="/assets/js/browser.min.js"></script>
        <script src="/assets/js/breakpoints.min.js"></script>
        <script src="/assets/js/util.js"></script>
        <script src="/assets/js/main.js"></script>
    </div>
</body>

</html>